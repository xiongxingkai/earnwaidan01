console.log(1&2);

console.log(1&&2);

// 上面打印的结果是什么呢？

// 先别急着回答，我们先复习一下JS中的逻辑运算符&& 与，左边为真才走右边，左边为假只走左边。

// 在JS世界中，一共有这几种情况被认定为假：fase,undefined,'',null,0与神奇的NaN。

console.log(0&&1); 左边为假，不走了，打印结果为0;

console.log(undefined&&1);左边为假，程序不走了，弹出的结果为undefined;

console.log(true&&'');左边为真，程序继续，弹出的结果为'';

console.log(NaN&&true);左边为假，程序不走了，弹出NaN;

// 再看上面的第二个，答案就很明显了。

// 1和2都是number类型的数字，显然都是真的，1是真的，向后走，所以打印出来的结果自然是2了，那么1&2呢？

// 打印出来的结果为0；

// 为什么呢？好像很不科学的样子。



// &&是逻辑运算符，&到底是个什么鬼？

// 本着钻研第一的原则，我又相继的打印了



// 打印出来的结果看上去和逻辑与的作用差不多，两边为真即为真，打印出1。一边为假即为假，打印0。可1和2是两个明明白白的Number啊，为何打印出来的结果也为0呢，

// 原来，&是表示位的与运算，把左右两边的数字转化为二进制，然后每一位分别进行比较，如果相等就为1，不相等即为0。同时&具有强制转换的功能，把false,true转换成了0和1进行比较。而0又表示false的意思，所以带有false的都挂掉了，偶尔也可以当做逻辑与来使用。 

// 1转换为二进制为1,2转换为二进制为10，  所以1&2实际是0001&0010,没有相等的部分，最终结果就是0了。

// 我们再来做一个练习

// console.log(34&7);

// 打印出来的结果是什么呢？

// 34进行二进制转换，得到的结果是100010,

//    7进行二进制转换，得到的结果是000111,

// 注意，进行比较的时候，如果两边数字的长度不够，就从右到左对齐，    前面没有的部分补零就好，就像111和100010比较，为了大家能看的更清楚一点，我在111的前面加了三个0。

// 所以JS解析的结果为100010&000111,只有倒数第二位是相等的，解析出来的结果就是10,转换为十进制就是2，所以打印出来的结果就是2了。

// 我们平时在进行奇数偶数判断的时候一般会写

if(n%2 ===1 ){

console.log('奇数')

}else{

console.log('偶数')

}

但这样显然是更麻烦一点的，因为平时的这些数值计算，计算机是要先转换成二进制再进行计算的，位运算是直接用二进制来进行计算的，如果我们用位运算符&来进行判断的话，计算速度就会提升很多。

if(n&1){

    console.log('奇数')//奇数转为二进制最后一位肯定是1，而偶数二进制的最后一位是0，1转换为二进制还是1，所以判断的结果只会是0或者1.

}else{

    console.log('偶数')

}

